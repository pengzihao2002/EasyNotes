
### 图像入门
基础操作

图像基础
img = cv.imread() # 图像读取
img.shape # 图像尺寸，彩色图像返回一个元组(行，列，通道数),灰度图像只有行和列，是检测加载的图像是彩色还是灰度图像的简便方法
img.size # 图像像素总数

img.dtype # 图像数据类型，常见有uint8, float32等
!!!img.dtype在调试中十分重要，opencv-python大量错误都是由于无效的数据类型导致的

px = img[高/行/y/row, 宽/列/x/column] # 获取像素值
blue = img[100, 100, 0] # 获取蓝色通道的像素值
img.item(100, 100, 0) # 获取像素值(推荐)
img[100, 100] = [255,255,255] # 修改像素值
img.itemset((10,10,2),100) # 修改像素值(推荐)
ingCropped = img[0:300, 100:400] # 图像裁剪
cv.imshow() # 图像展示

### 图像ROI
Region of Interest，即感兴趣区域，指用方框、圆形、椭圆、不规则多边形等方式勾勒出图像需要处理的区域
```
cv.copyMakeBorder(src,top,bottom,left,,right,borderType,[value])

ball = img[280:340, 330:390] # 获取球区域
img[273:333, 100:160] = ball # 将球域粘贴到指定位置
b,g,r = cv.split(img) 或 b = img[:,:,0] # 拆分图像通道
img = cv.merge((b,g,r)) # 合并图像通道
img[:,:,2] = 0 # 将图像的红色通道置为0，无需先拆分通道，Numpy索引更快，不推荐cv.split比较耗时
```
### 图像算术运算(Arithmetic Operations on Images)

#### 图像添加
```

# 添加的两个图像应具有相同的深度和类型，或者第二个图像只能是标量值

x = np.uint8([250])
y = np.uint8([10])
print(cv.add(x,y)) # 250+10 = 260 => 255 推荐使用
[[255]]
print(x+y) # 250+10 = 260 % 256 = 4
[4]
cv.add() # 用于合并两个图像，OpenCV加法是饱和运算，而 Numpy加法是模运算
```
#### 图像混合
公式：
$g(x) = (1−α)f_0(x) + αf_1(x)$ # g(x)是混合图像，f0(x)和f1(x)是输入图像
$dst = α⋅img1 + β⋅img2 + γ$ # α是权重系数，α + β = 1，γ是可选的亮度偏移量
```
cv.addWeighted(img1,α,img2,β,γ) # 将上述的公式运用到图像中

img1 = cv.imread('ml.png')
img2 = cv.imread('opencv-logo.png')
dst = cv.addWeighted(img1,0.7,img2,0.3,0)

cv.bitwise_and(img, img, mask=None) # 按位与运算，只有当mask不等于0时才会对mask内的像素进行运算
dst(I)=src1(I)∧src2(I), if mask(I) not = 0 # 按位与运算公式，只有当mask内的像素值不等于0时才会进行运算，就是说等于0的值会被忽略
cv.bitwise_not(mask) # 掩码取反

ret, mask = cv.threshold(img2gray, thresh, maxval, cv.THRESH_BINARY)
mask # 蒙版或叫掩码，是输出的二值图像，只有黑和白，黑就是忽略不参与运算，白就是按位与运算
img2gray # 灰度图像
thresh # 阈值，执行阈值操作时，像素值会根据这个阈值被处理
maxval # 最大值，该值与 THRESH_BINARY或THRESH_BINARY_INV 类型配合使用。当满足条件的像素被置为 maxval，不满足条件的像素则被置为 0 或其他值（取决于阈值类型）
type # 阈值类型：
THRESH_BINARY：超过阈值的像素被置为 maxval，否则置为 0。
THRESH_BINARY_INV：低于阈值的像素被置为 maxval，否则置为 0。
THRESH_TRUNC：超过阈值的像素被截断为阈值，低于阈值的像素不变。
THRESH_TOZERO：低于阈值的像素被置为 0，超过阈值的像素不变。
THRESH_TOZERO_INV：超过阈值的像素被置为 0，低于阈值的像素不变。
另外，THRESH_OTSU 和 THRESH_TRIANGLE 是两个特殊的值，它们可以与其他类型组合使用。当这些方法被使用时，函数会自动根据图像内容计算最优的阈值，而不是使用指定的 thresh 值。
```
cv.waitkey() # 等待按键
cap = cv.VideoCapture() # 视频采集
cap.set(属性索引值，属性值)
cap.isOpened() # 是否打开成功，返回布尔值
ret, frame = cap.read() # ret为是否读取成功，frame为读取的帧
cv.namedWindow('Video', cv.WINDOW_NORMAL) # 创建窗口
cv.resizeWindow('Video', (宽, 高) ) # 调整窗口大小
cv.resize(img, (宽, 高)) # 调整图像大小


import numpy as np # numpy是Python的一个著名的开源科学计算库
kernel = np.ones((5,5),npuint8) # 内核，一个数组
iteration = 1 # 迭代器，指定迭代次数
imgGray = cv.cvtColor(img, cv.COLOR_BGR2GRAY) # 灰度图像
imgBlur = cv.GaussianBlur(imgGray, (7,7),0) # 高斯模糊
imgCanny = cv.Canny(img,150,200) # 边缘算法，后两个参数对应设置的阈值
imgDilation = cv.dilation(imgCanny, kernel , iteration=1) # 膨胀处理
imgEroded = cv.erode(imgDialation, kernel , iteration=1) # 腐蚀处理















